{"version":3,"sources":["webpack://jfrog-ui-essentials/./node_modules/vue-select/src/mixins/pointerScroll.js","webpack://jfrog-ui-essentials/./node_modules/vue-select/src/mixins/ajax.js","webpack://jfrog-ui-essentials/./node_modules/vue-select/src/mixins/typeAheadPointer.js"],"names":["module","exports","watch","[object Object]","this","maybeAdjustScroll","methods","pixelsToPointerTop","pixelsToPointerBottom","viewport","top","scrollTo","bottom","pointerHeight","$refs","dropdownMenu","i","typeAheadPointer","children","offsetHeight","element","scrollTop","position","props","loading","type","Boolean","default","onSearch","Function","search","mutableLoading","length","toggleLoading","$emit","val","toggle","filteredOptions","select","taggable","clearSearchOnSelect"],"mappings":"0LAEAA,EAAAC,QAAA,CACAC,MAAA,CACAC,mBACAC,KAAAC,sBAIAC,QAAA,CAOAH,oBACA,IAAAI,EAAAH,KAAAG,qBACAC,EAAAJ,KAAAI,wBAEA,OAAAD,GAAAH,KAAAK,WAAAC,IACAN,KAAAO,SAAAJ,GACOC,GAAAJ,KAAAK,WAAAG,OACPR,KAAAO,SAAAP,KAAAK,WAAAC,IAAAN,KAAAS,sBADO,GAUPV,qBACA,IAAAI,EAAA,EACA,GAAAH,KAAAU,MAAAC,aACA,QAAAC,EAAA,EAAuBA,EAAAZ,KAAAa,iBAA2BD,IAClDT,GAAAH,KAAAU,MAAAC,aAAAG,SAAAF,GAAAG,aAGA,OAAAZ,GAQAJ,wBACA,OAAAC,KAAAG,qBAAAH,KAAAS,iBAOAV,gBACA,IAAAiB,IAAAhB,KAAAU,MAAAC,cAAAX,KAAAU,MAAAC,aAAAG,SAAAd,KAAAa,kBACA,OAAAG,IAAAD,aAAA,GAOAhB,WACA,OACAO,IAAAN,KAAAU,MAAAC,aAAAX,KAAAU,MAAAC,aAAAM,UAAA,EACAT,OAAAR,KAAAU,MAAAC,aAAAX,KAAAU,MAAAC,aAAAI,aAAAf,KAAAU,MAAAC,aAAAM,UAAA,IASAlB,SAAAmB,GACA,OAAAlB,KAAAU,MAAAC,aAAAX,KAAAU,MAAAC,aAAAM,UAAAC,EAAA,4BC7EAtB,EAAAC,QAAA,CACAsB,MAAA,CAMAC,QAAA,CACAC,KAAAC,QACAC,SAAA,GAcAC,SAAA,CACAH,KAAAI,SACAF,QAAA,SAAAG,EAAAN,OAIArB,OACA,OACA4B,gBAAA,IAIA7B,MAAA,CAKAC,SACAC,KAAA0B,OAAAE,OAAA,IACA5B,KAAAwB,SAAAxB,KAAA0B,OAAA1B,KAAA6B,eACA7B,KAAA8B,MAAA,SAAA9B,KAAA0B,OAAA1B,KAAA6B,iBAQA9B,QAAAgC,GACA/B,KAAA2B,eAAAI,IAIA7B,QAAA,CAQAH,cAAAiC,EAAA,MACA,OACAhC,KAAA2B,eADA,MAAAK,GACAhC,KAAA2B,eAEAK,yBCpEApC,EAAAC,QAAA,CACAE,OACA,OACAc,kBAAA,IAIAf,MAAA,CACAC,kBACAC,KAAAa,iBAAA,IAIAX,QAAA,CAMAH,cACAC,KAAAa,iBAAA,IACAb,KAAAa,mBACAb,KAAAC,mBACAD,KAAAC,sBAUAF,gBACAC,KAAAa,iBAAAb,KAAAiC,gBAAAL,OAAA,IACA5B,KAAAa,mBACAb,KAAAC,mBACAD,KAAAC,sBAUAF,kBACAC,KAAAiC,gBAAAjC,KAAAa,kBACAb,KAAAkC,OAAAlC,KAAAiC,gBAAAjC,KAAAa,mBACOb,KAAAmC,UAAAnC,KAAA0B,OAAAE,QACP5B,KAAAkC,OAAAlC,KAAA0B,QAGA1B,KAAAoC,sBACApC,KAAA0B,OAAA","file":"jfrog-ui-essentials.umd.min.vendors-chunks~a1bdf38b.js","sourcesContent":["// flow\n\nmodule.exports = {\n  watch: {\n    typeAheadPointer() {\n      this.maybeAdjustScroll()\n    }\n  },\n\n  methods: {\n    /**\n     * Adjust the scroll position of the dropdown list\n     * if the current pointer is outside of the\n     * overflow bounds.\n     * @returns {*}\n     */\n    maybeAdjustScroll() {\n      let pixelsToPointerTop = this.pixelsToPointerTop()\n      let pixelsToPointerBottom = this.pixelsToPointerBottom()\n\n      if ( pixelsToPointerTop <= this.viewport().top) {\n        return this.scrollTo( pixelsToPointerTop )\n      } else if (pixelsToPointerBottom >= this.viewport().bottom) {\n        return this.scrollTo( this.viewport().top + this.pointerHeight() )\n      }\n    },\n\n    /**\n     * The distance in pixels from the top of the dropdown\n     * list to the top of the current pointer element.\n     * @returns {number}\n     */\n    pixelsToPointerTop() {\n      let pixelsToPointerTop = 0\n      if( this.$refs.dropdownMenu ) {\n        for (let i = 0; i < this.typeAheadPointer; i++) {\n          pixelsToPointerTop += this.$refs.dropdownMenu.children[i].offsetHeight\n        }\n      }\n      return pixelsToPointerTop\n    },\n\n    /**\n     * The distance in pixels from the top of the dropdown\n     * list to the bottom of the current pointer element.\n     * @returns {*}\n     */\n    pixelsToPointerBottom() {\n      return this.pixelsToPointerTop() + this.pointerHeight()\n    },\n\n    /**\n     * The offsetHeight of the current pointer element.\n     * @returns {number}\n     */\n    pointerHeight() {\n      let element = this.$refs.dropdownMenu ? this.$refs.dropdownMenu.children[this.typeAheadPointer] : false\n      return element ? element.offsetHeight : 0\n    },\n\n    /**\n     * The currently viewable portion of the dropdownMenu.\n     * @returns {{top: (string|*|number), bottom: *}}\n     */\n    viewport() {\n      return {\n        top: this.$refs.dropdownMenu ? this.$refs.dropdownMenu.scrollTop: 0,\n        bottom: this.$refs.dropdownMenu ? this.$refs.dropdownMenu.offsetHeight + this.$refs.dropdownMenu.scrollTop : 0\n      }\n    },\n\n    /**\n     * Scroll the dropdownMenu to a given position.\n     * @param position\n     * @returns {*}\n     */\n    scrollTo(position) {\n      return this.$refs.dropdownMenu ? this.$refs.dropdownMenu.scrollTop = position : null\n    },\n  }\n}\n","module.exports = {\n\tprops: {\n\t\t/**\n\t\t * Toggles the adding of a 'loading' class to the main\n\t\t * .v-select wrapper. Useful to control UI state when\n\t\t * results are being processed through AJAX.\n\t\t */\n\t\tloading: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false\n\t\t},\n\n\t\t/**\n\t\t * Accept a callback function that will be\n\t\t * run when the search text changes.\n\t\t *\n\t\t * loading() accepts a boolean value, and can\n\t\t * be used to toggle a loading class from\n\t\t * the onSearch callback.\n\t\t *\n\t\t * @param {search}  String          Current search text\n\t\t * @param {loading} Function(bool)  Toggle loading class\n\t\t */\n\t\tonSearch: {\n\t\t\ttype: Function,\n\t\t\tdefault: function(search, loading){}\n\t\t}\n\t},\n\n\tdata() {\n\t\treturn {\n      mutableLoading: false\n    }\n\t},\n\n\twatch: {\n\t\t/**\n\t\t * If a callback & search text has been provided,\n\t\t * invoke the onSearch callback.\n\t\t */\n\t\tsearch() {\n\t\t\tif (this.search.length > 0) {\n\t\t\t\tthis.onSearch(this.search, this.toggleLoading)\n        this.$emit('search', this.search, this.toggleLoading)\n      }\n\t\t},\n    /**\n\t\t * Sync the loading prop with the internal\n\t\t * mutable loading value.\n     * @param val\n     */\n\t\tloading(val) {\n\t\t\tthis.mutableLoading = val\n\t\t}\n\t},\n\n\tmethods: {\n\t\t/**\n\t\t * Toggle this.loading. Optionally pass a boolean\n\t\t * value. If no value is provided, this.loading\n\t\t * will be set to the opposite of it's current value.\n\t\t * @param toggle Boolean\n\t\t * @returns {*}\n\t\t */\n\t\ttoggleLoading(toggle = null) {\n\t\t\tif (toggle == null) {\n\t\t\t\treturn this.mutableLoading = !this.mutableLoading\n\t\t\t}\n\t\t\treturn this.mutableLoading = toggle\n\t\t}\n\t}\n}\n","module.exports = {\n  data() {\n    return {\n      typeAheadPointer: -1\n    }\n  },\n\n  watch: {\n    filteredOptions() {\n      this.typeAheadPointer = 0\n    }\n  },\n\n  methods: {\n    /**\n     * Move the typeAheadPointer visually up the list by\n     * subtracting the current index by one.\n     * @return {void}\n     */\n    typeAheadUp() {\n      if (this.typeAheadPointer > 0) {\n        this.typeAheadPointer--\n        if( this.maybeAdjustScroll ) {\n          this.maybeAdjustScroll()\n        }\n      }\n    },\n\n    /**\n     * Move the typeAheadPointer visually down the list by\n     * adding the current index by one.\n     * @return {void}\n     */\n    typeAheadDown() {\n      if (this.typeAheadPointer < this.filteredOptions.length - 1) {\n        this.typeAheadPointer++\n        if( this.maybeAdjustScroll ) {\n          this.maybeAdjustScroll()\n        }\n      }\n    },\n\n    /**\n     * Select the option at the current typeAheadPointer position.\n     * Optionally clear the search input on selection.\n     * @return {void}\n     */\n    typeAheadSelect() {\n      if( this.filteredOptions[ this.typeAheadPointer ] ) {\n        this.select( this.filteredOptions[ this.typeAheadPointer ] );\n      } else if (this.taggable && this.search.length){\n        this.select(this.search)\n      }\n\n      if( this.clearSearchOnSelect ) {\n        this.search = \"\";\n      }\n    },\n  }\n}"],"sourceRoot":""}