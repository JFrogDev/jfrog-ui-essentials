{"version":3,"sources":["webpack://jfrog-ui-essentials/./node_modules/source-map/lib/source-map-consumer.js"],"names":["util","__webpack_require__","binarySearch","ArraySet","base64VLQ","quickSort","SourceMapConsumer","aSourceMap","aSourceMapURL","sourceMap","parseSourceMapInput","sections","IndexedSourceMapConsumer","BasicSourceMapConsumer","version","getArg","sources","names","sourceRoot","sourcesContent","mappings","file","this","_version","Error","normalize","map","String","source","isAbsolute","relative","_names","fromArray","_sources","_absoluteSources","toArray","s","computeSourceURL","_mappings","_sourceMapURL","Mapping","generatedLine","generatedColumn","originalLine","originalColumn","name","lastOffset","line","column","_sections","url","offset","offsetLine","offsetColumn","generatedOffset","consumer","fromSourceMap","prototype","__generatedMappings","Object","defineProperty","configurable","enumerable","get","_parseMappings","__originalMappings","_charIsMappingSeparator","aStr","index","c","charAt","aSourceRoot","GENERATED_ORDER","ORIGINAL_ORDER","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","eachMapping","aCallback","aContext","aOrder","context","order","_generatedMappings","_originalMappings","mapping","at","forEach","allGeneratedPositionsFor","aArgs","needle","_findSourceIndex","_findMapping","compareByOriginalPositions","undefined","push","lastColumn","exports","create","aSource","i","relativeSource","has","indexOf","length","smc","_sourceRoot","_generateSourcesContent","_file","generatedMappings","slice","destGeneratedMappings","destOriginalMappings","srcMapping","destMapping","str","segment","end","value","previousGeneratedColumn","previousOriginalLine","previousOriginalColumn","previousSource","previousName","cachedSegments","temp","originalMappings","decode","rest","compareByGeneratedPositionsDeflated","aNeedle","aMappings","aLineName","aColumnName","aComparator","aBias","TypeError","search","computeColumnSpans","nextMapping","lastGeneratedColumn","Infinity","originalPositionFor","hasContentsOfAllSources","size","some","sc","sourceContentFor","nullOnMissing","urlParse","fileUriAbsPath","replace","scheme","path","generatedPositionFor","constructor","j","sectionIndex","section","cmp","bias","every","content","generatedPosition","ret","sectionMappings","add","adjustedMapping"],"mappings":"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","file":"jfrog-ui-essentials.umd.min.vendors-chunks~e9435ba4.js","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  if (sourceRoot) {\n    sourceRoot = util.normalize(sourceRoot);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this._absoluteSources = this._sources.toArray().map(function (s) {\n    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n  });\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this._sourceMapURL = aSourceMapURL;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */\nBasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n  var relativeSource = aSource;\n  if (this.sourceRoot != null) {\n    relativeSource = util.relative(this.sourceRoot, relativeSource);\n  }\n\n  if (this._sources.has(relativeSource)) {\n    return this._sources.indexOf(relativeSource);\n  }\n\n  // Maybe aSource is an absolute URL as returned by |sources|.  In\n  // this case we can't simply undo the transform.\n  var i;\n  for (i = 0; i < this._absoluteSources.length; ++i) {\n    if (this._absoluteSources[i] == aSource) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc._sourceMapURL = aSourceMapURL;\n    smc._absoluteSources = smc._sources.toArray().map(function (s) {\n      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n    });\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._absoluteSources.slice();\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    var index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = null;\n        if (mapping.name) {\n          name = section.consumer._names.at(mapping.name);\n          this._names.add(name);\n          name = this._names.indexOf(name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n"],"sourceRoot":""}