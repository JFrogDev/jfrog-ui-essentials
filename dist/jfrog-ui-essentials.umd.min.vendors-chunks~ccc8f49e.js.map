{"version":3,"sources":["webpack://jfrog-ui-essentials/./node_modules/codemirror/addon/search/searchcursor.js"],"names":["mod","__webpack_require__","CodeMirror","doFold","noFold","Pos","regexpFlags","regexp","flags","ignoreCase","global","multiline","ensureFlags","current","target","i","length","indexOf","charAt","RegExp","source","maybeMultiline","test","searchRegexpForward","doc","start","line","ch","last","lastLine","lastIndex","string","getLine","match","exec","from","index","to","searchRegexpForwardMultiline","chunk","curLine","before","slice","split","inside","startLine","startCh","lastMatchIn","cutOff","newMatch","searchRegexpBackward","first","firstLine","searchRegexpBackwardMultiline","adjustPos","orig","folded","pos","foldFunc","min","max","Math","mid","len","searchStringForward","query","caseFold","fold","lines","search","found","cutFrom","end","endString","searchStringBackward","lastIndexOf","top","topString","SearchCursor","options","this","atOccurrence","clipPos","matches","reverse","String","prototype","normalize","str","toLowerCase","findNext","find","findPrevious","result","cmpPos","replace","newText","origin","splitLines","replaceRange","defineExtension","defineDocExtension","ranges","cur","getSearchCursor","getCursor","push","anchor","head","setSelections"],"mappings":"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","file":"jfrog-ui-essentials.umd.min.vendors-chunks~ccc8f49e.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n  var Pos = CodeMirror.Pos\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\n      + (regexp.global ? \"g\" : \"\")\n      + (regexp.multiline ? \"m\" : \"\")\n  }\n\n  function ensureFlags(regexp, flags) {\n    var current = regexpFlags(regexp), target = current\n    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)\n      target += flags.charAt(i)\n    return current == target ? regexp : new RegExp(regexp.source, target)\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch\n      var string = doc.getLine(line), match = regexp.exec(string)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\n\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        if (line > last) break\n        var curLine = doc.getLine(line++)\n        string = string == null ? curLine : string + \"\\n\" + curLine\n      }\n      chunk = chunk * 2\n      regexp.lastIndex = start.ch\n      var match = regexp.exec(string)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp) {\n    var cutOff = 0, match\n    for (;;) {\n      regexp.lastIndex = cutOff\n      var newMatch = regexp.exec(string)\n      if (!newMatch) return match\n      match = newMatch\n      cutOff = match.index + (match[0].length || 1)\n      if (cutOff == string.length) return match\n    }\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line)\n      if (ch > -1) string = string.slice(0, ch)\n      var match = lastMatchIn(string, regexp)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunk; i++) {\n        var curLine = doc.getLine(line--)\n        string = string == null ? curLine.slice(0, start.ch) : curLine + \"\\n\" + string\n      }\n      chunk *= 2\n\n      var match = lastMatchIn(string, regexp)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = line + before.length, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  var doFold, noFold\n  if (String.prototype.normalize) {\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\n    noFold = function(str) { return str.normalize(\"NFD\") }\n  } else {\n    doFold = function(str) { return str.toLowerCase() }\n    noFold = function(str) { return str }\n  }\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min\n      var mid = (min + max) >> 1\n      var len = foldFunc(orig.slice(0, mid)).length\n      if (len == pos) return mid\n      else if (len > pos) max = mid\n      else min = mid + 1\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0])\n        if (found == -1) continue search\n        var start = adjustPos(orig, string, found, fold) + ch\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\n      } else {\n        var cutFrom = string.length - lines[0].length\n        if (string.slice(cutFrom) != lines[0]) continue search\n        for (var i = 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\n        if (endString.slice(0, lastLine.length) != lastLine) continue search\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line)\n      if (ch > -1) orig = orig.slice(0, ch)\n      var string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0])\n        if (found == -1) continue search\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\n      } else {\n        var lastLine = lines[lines.length - 1]\n        if (string.slice(0, lastLine.length) != lastLine) continue search\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false\n    this.doc = doc\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\n    this.pos = {from: pos, to: pos}\n\n    var caseFold\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold\n    } else { // Backwards compat for when caseFold was the 4th argument\n      caseFold = options\n      options = null\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false\n      this.matches = function(reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\n      }\n    } else {\n      query = ensureFlags(query, \"gm\")\n      if (!options || options.multiline !== false)\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\n        }\n      else\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\n        }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false)},\n    findPrevious: function() {return this.find(true)},\n\n    find: function(reverse) {\n      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to))\n\n      // Implements weird auto-growing behavior on null-matches for\n      // backwards-compatiblity with the vim code (unfortunately)\n      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {\n        if (reverse) {\n          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1)\n          else if (result.from.line == this.doc.firstLine()) result = null\n          else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)))\n        } else {\n          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1)\n          else if (result.to.line == this.doc.lastLine()) result = null\n          else result = this.matches(reverse, Pos(result.to.line + 1, 0))\n        }\n      }\n\n      if (result) {\n        this.pos = result\n        this.atOccurrence = true\n        return this.pos.match || true\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\n        this.pos = {from: end, to: end}\n        return this.atOccurrence = false\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from},\n    to: function() {if (this.atOccurrence) return this.pos.to},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return\n      var lines = CodeMirror.splitLines(newText)\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold)\n  })\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold)\n  })\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = []\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\n      ranges.push({anchor: cur.from(), head: cur.to()})\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0)\n  })\n});\n"],"sourceRoot":""}