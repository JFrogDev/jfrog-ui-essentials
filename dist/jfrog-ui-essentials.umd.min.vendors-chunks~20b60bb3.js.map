{"version":3,"sources":["webpack://jfrog-ui-essentials/./node_modules/sanitize-html/dist/index.js"],"names":["htmlparser","__webpack_require__","extend","quoteRegexp","cloneDeep","mergeWith","isString","isPlainObject","srcset","postcss","url","each","obj","cb","Object","keys","forEach","key","has","hasOwnProperty","call","filter","a","n","v","push","module","exports","sanitizeHtml","VALID_HTML_ATTRIBUTE_NAME","html","options","_recursing","result","Frame","tag","attribs","that","this","tagPosition","length","text","updateParentNodeText","stack","parentFrame","defaults","parser","htmlParserDefaults","allowedAttributesMap","allowedAttributesGlobMap","nonTextTagsArray","nonTextTags","allowedAttributes","attributes","globRegex","indexOf","replace","RegExp","join","allowedClassesMap","allowedClasses","classes","transformTagsAll","transformTagsMap","transformTags","transform","transFun","simpleTransform","depth","skipMap","transformMap","skipText","skipTextDepth","Parser","onopentag","name","frame","transformedTag","skip","hasText","undefined","innerText","tagName","allowedTags","value","test","parsed","passedAllowedAttributesMapCheck","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","o","newValue","multiple","splitStrArray","split","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","s","values","err","return","allowedSchemesAppliedToAttributes","naughtyHref","allowed","parse","isRelativeUrl","host","protocol","allowIframeRelativeUrls","allowedIframeHostnames","find","hostname","e","evil","stringify","filterClasses","abstractSyntaxTree","filteredAST","filterCss","allowedStyles","stringifyStyleAttributes","escapeHtml","selfClosing","textFilter","ontext","lastFrame","escaped","onclosetag","pop","exclusiveFilter","substr","write","end","quote","decodeEntities","href","matches","match","allowProtocolRelative","scheme","toLowerCase","allowedSchemesByTag","allowedSchemes","selectedRule","astRules","nodes","selector","objValue","srcValue","Array","isArray","concat","reduce","filterDeclarations","extractedAttributes","attributeObject","prop","allowedDeclarationsList","matchesRegex","some","regularExpression","clss","img","newTagName","newAttribs","merge","attrib"],"mappings":"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","file":"jfrog-ui-essentials.umd.min.vendors-chunks~20b60bb3.js","sourcesContent":["'use strict';\n\nvar htmlparser = require('htmlparser2');\nvar extend = require('xtend');\nvar quoteRegexp = require('lodash.escaperegexp');\nvar cloneDeep = require('lodash.clonedeep');\nvar mergeWith = require('lodash.mergewith');\nvar isString = require('lodash.isstring');\nvar isPlainObject = require('lodash.isplainobject');\nvar srcset = require('srcset');\nvar postcss = require('postcss');\nvar url = require('url');\n\nfunction each(obj, cb) {\n  if (obj) Object.keys(obj).forEach(function (key) {\n    cb(obj[key], key);\n  });\n}\n\n// Avoid false positives with .__proto__, .hasOwnProperty, etc.\nfunction has(obj, key) {\n  return {}.hasOwnProperty.call(obj, key);\n}\n\n// Returns those elements of `a` for which `cb(a)` returns truthy\nfunction filter(a, cb) {\n  var n = [];\n  each(a, function (v) {\n    if (cb(v)) {\n      n.push(v);\n    }\n  });\n  return n;\n}\n\nmodule.exports = sanitizeHtml;\n\n// A valid attribute name.\n// We use a tolerant definition based on the set of strings defined by\n// html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state\n// and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .\n// The characters accepted are ones which can be appended to the attribute\n// name buffer without triggering a parse error:\n//   * unexpected-equals-sign-before-attribute-name\n//   * unexpected-null-character\n//   * unexpected-character-in-attribute-name\n// We exclude the empty string because it's impossible to get to the after\n// attribute name state with an empty attribute name buffer.\nvar VALID_HTML_ATTRIBUTE_NAME = /^[^\\0\\t\\n\\f\\r /<=>]+$/;\n\n// Ignore the _recursing flag; it's there for recursive\n// invocation as a guard against this exploit:\n// https://github.com/fb55/htmlparser2/issues/105\n\nfunction sanitizeHtml(html, options, _recursing) {\n  var result = '';\n\n  function Frame(tag, attribs) {\n    var that = this;\n    this.tag = tag;\n    this.attribs = attribs || {};\n    this.tagPosition = result.length;\n    this.text = ''; // Node inner text\n\n    this.updateParentNodeText = function () {\n      if (stack.length) {\n        var parentFrame = stack[stack.length - 1];\n        parentFrame.text += that.text;\n      }\n    };\n  }\n\n  if (!options) {\n    options = sanitizeHtml.defaults;\n    options.parser = htmlParserDefaults;\n  } else {\n    options = extend(sanitizeHtml.defaults, options);\n    if (options.parser) {\n      options.parser = extend(htmlParserDefaults, options.parser);\n    } else {\n      options.parser = htmlParserDefaults;\n    }\n  }\n\n  // Tags that contain something other than HTML, or where discarding\n  // the text when the tag is disallowed makes sense for other reasons.\n  // If we are not allowing these tags, we should drop their content too.\n  // For other tags you would drop the tag but keep its content.\n  var nonTextTagsArray = options.nonTextTags || ['script', 'style', 'textarea'];\n  var allowedAttributesMap;\n  var allowedAttributesGlobMap;\n  if (options.allowedAttributes) {\n    allowedAttributesMap = {};\n    allowedAttributesGlobMap = {};\n    each(options.allowedAttributes, function (attributes, tag) {\n      allowedAttributesMap[tag] = [];\n      var globRegex = [];\n      attributes.forEach(function (obj) {\n        if (isString(obj) && obj.indexOf('*') >= 0) {\n          globRegex.push(quoteRegexp(obj).replace(/\\\\\\*/g, '.*'));\n        } else {\n          allowedAttributesMap[tag].push(obj);\n        }\n      });\n      allowedAttributesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n    });\n  }\n  var allowedClassesMap = {};\n  each(options.allowedClasses, function (classes, tag) {\n    // Implicitly allows the class attribute\n    if (allowedAttributesMap) {\n      if (!has(allowedAttributesMap, tag)) {\n        allowedAttributesMap[tag] = [];\n      }\n      allowedAttributesMap[tag].push('class');\n    }\n\n    allowedClassesMap[tag] = classes;\n  });\n\n  var transformTagsMap = {};\n  var transformTagsAll;\n  each(options.transformTags, function (transform, tag) {\n    var transFun;\n    if (typeof transform === 'function') {\n      transFun = transform;\n    } else if (typeof transform === \"string\") {\n      transFun = sanitizeHtml.simpleTransform(transform);\n    }\n    if (tag === '*') {\n      transformTagsAll = transFun;\n    } else {\n      transformTagsMap[tag] = transFun;\n    }\n  });\n\n  var depth = 0;\n  var stack = [];\n  var skipMap = {};\n  var transformMap = {};\n  var skipText = false;\n  var skipTextDepth = 0;\n\n  var parser = new htmlparser.Parser({\n    onopentag: function onopentag(name, attribs) {\n      if (skipText) {\n        skipTextDepth++;\n        return;\n      }\n      var frame = new Frame(name, attribs);\n      stack.push(frame);\n\n      var skip = false;\n      var hasText = frame.text ? true : false;\n      var transformedTag;\n      if (has(transformTagsMap, name)) {\n        transformedTag = transformTagsMap[name](name, attribs);\n\n        frame.attribs = attribs = transformedTag.attribs;\n\n        if (transformedTag.text !== undefined) {\n          frame.innerText = transformedTag.text;\n        }\n\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n      if (transformTagsAll) {\n        transformedTag = transformTagsAll(name, attribs);\n\n        frame.attribs = attribs = transformedTag.attribs;\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n\n      if (options.allowedTags && options.allowedTags.indexOf(name) === -1) {\n        skip = true;\n        if (nonTextTagsArray.indexOf(name) !== -1) {\n          skipText = true;\n          skipTextDepth = 1;\n        }\n        skipMap[depth] = true;\n      }\n      depth++;\n      if (skip) {\n        // We want the contents but not this tag\n        return;\n      }\n      result += '<' + name;\n      if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap['*']) {\n        each(attribs, function (value, a) {\n          if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {\n            // This prevents part of an attribute name in the output from being\n            // interpreted as the end of an attribute, or end of a tag.\n            delete frame.attribs[a];\n            return;\n          }\n          var parsed;\n          // check allowedAttributesMap for the element and attribute and modify the value\n          // as necessary if there are specific values defined.\n          var passedAllowedAttributesMapCheck = false;\n          if (!allowedAttributesMap || has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1 || allowedAttributesMap['*'] && allowedAttributesMap['*'].indexOf(a) !== -1 || has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a) || allowedAttributesGlobMap['*'] && allowedAttributesGlobMap['*'].test(a)) {\n            passedAllowedAttributesMapCheck = true;\n          } else if (allowedAttributesMap && allowedAttributesMap[name]) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = allowedAttributesMap[name][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var o = _step.value;\n\n                if (isPlainObject(o) && o.name && o.name === a) {\n                  passedAllowedAttributesMapCheck = true;\n                  var newValue = '';\n                  if (o.multiple === true) {\n                    // verify the values that are allowed\n                    var splitStrArray = value.split(' ');\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n\n                    try {\n                      for (var _iterator2 = splitStrArray[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                        var s = _step2.value;\n\n                        if (o.values.indexOf(s) !== -1) {\n                          if (newValue === '') {\n                            newValue = s;\n                          } else {\n                            newValue += ' ' + s;\n                          }\n                        }\n                      }\n                    } catch (err) {\n                      _didIteratorError2 = true;\n                      _iteratorError2 = err;\n                    } finally {\n                      try {\n                        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                          _iterator2.return();\n                        }\n                      } finally {\n                        if (_didIteratorError2) {\n                          throw _iteratorError2;\n                        }\n                      }\n                    }\n                  } else if (o.values.indexOf(value) >= 0) {\n                    // verified an allowed value matches the entire attribute value\n                    newValue = value;\n                  }\n                  value = newValue;\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n          }\n          if (passedAllowedAttributesMapCheck) {\n            if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {\n              if (naughtyHref(name, value)) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (name === 'iframe' && a === 'src') {\n              var allowed = true;\n              try {\n                // naughtyHref is in charge of whether protocol relative URLs\n                // are cool. We should just accept them\n                parsed = url.parse(value, false, true);\n                var isRelativeUrl = parsed && parsed.host === null && parsed.protocol === null;\n                if (isRelativeUrl) {\n                  // default value of allowIframeRelativeUrls is true unless allowIframeHostnames specified\n                  allowed = has(options, \"allowIframeRelativeUrls\") ? options.allowIframeRelativeUrls : !options.allowedIframeHostnames;\n                } else if (options.allowedIframeHostnames) {\n                  allowed = options.allowedIframeHostnames.find(function (hostname) {\n                    return hostname === parsed.hostname;\n                  });\n                }\n              } catch (e) {\n                // Unparseable iframe src\n                allowed = false;\n              }\n              if (!allowed) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'srcset') {\n              try {\n                parsed = srcset.parse(value);\n                each(parsed, function (value) {\n                  if (naughtyHref('srcset', value.url)) {\n                    value.evil = true;\n                  }\n                });\n                parsed = filter(parsed, function (v) {\n                  return !v.evil;\n                });\n                if (!parsed.length) {\n                  delete frame.attribs[a];\n                  return;\n                } else {\n                  value = srcset.stringify(filter(parsed, function (v) {\n                    return !v.evil;\n                  }));\n                  frame.attribs[a] = value;\n                }\n              } catch (e) {\n                // Unparseable srcset\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'class') {\n              value = filterClasses(value, allowedClassesMap[name]);\n              if (!value.length) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'style') {\n              try {\n                var abstractSyntaxTree = postcss.parse(name + \" {\" + value + \"}\");\n                var filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);\n\n                value = stringifyStyleAttributes(filteredAST);\n\n                if (value.length === 0) {\n                  delete frame.attribs[a];\n                  return;\n                }\n              } catch (e) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            result += ' ' + a;\n            if (value.length) {\n              result += '=\"' + escapeHtml(value, true) + '\"';\n            }\n          } else {\n            delete frame.attribs[a];\n          }\n        });\n      }\n      if (options.selfClosing.indexOf(name) !== -1) {\n        result += \" />\";\n      } else {\n        result += \">\";\n        if (frame.innerText && !hasText && !options.textFilter) {\n          result += frame.innerText;\n        }\n      }\n    },\n    ontext: function ontext(text) {\n      if (skipText) {\n        return;\n      }\n      var lastFrame = stack[stack.length - 1];\n      var tag;\n\n      if (lastFrame) {\n        tag = lastFrame.tag;\n        // If inner text was set by transform function then let's use it\n        text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;\n      }\n\n      if (tag === 'script' || tag === 'style') {\n        // htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing\n        // script tags is, by definition, game over for XSS protection, so if that's\n        // your concern, don't allow them. The same is essentially true for style tags\n        // which have their own collection of XSS vectors.\n        result += text;\n      } else {\n        var escaped = escapeHtml(text, false);\n        if (options.textFilter) {\n          result += options.textFilter(escaped);\n        } else {\n          result += escaped;\n        }\n      }\n      if (stack.length) {\n        var frame = stack[stack.length - 1];\n        frame.text += text;\n      }\n    },\n    onclosetag: function onclosetag(name) {\n\n      if (skipText) {\n        skipTextDepth--;\n        if (!skipTextDepth) {\n          skipText = false;\n        } else {\n          return;\n        }\n      }\n\n      var frame = stack.pop();\n      if (!frame) {\n        // Do not crash on bad markup\n        return;\n      }\n      skipText = false;\n      depth--;\n      if (skipMap[depth]) {\n        delete skipMap[depth];\n        frame.updateParentNodeText();\n        return;\n      }\n\n      if (transformMap[depth]) {\n        name = transformMap[depth];\n        delete transformMap[depth];\n      }\n\n      if (options.exclusiveFilter && options.exclusiveFilter(frame)) {\n        result = result.substr(0, frame.tagPosition);\n        return;\n      }\n\n      frame.updateParentNodeText();\n\n      if (options.selfClosing.indexOf(name) !== -1) {\n        // Already output />\n        return;\n      }\n\n      result += \"</\" + name + \">\";\n    }\n  }, options.parser);\n  parser.write(html);\n  parser.end();\n\n  return result;\n\n  function escapeHtml(s, quote) {\n    if (typeof s !== 'string') {\n      s = s + '';\n    }\n    if (options.parser.decodeEntities) {\n      s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\>/g, '&gt;');\n      if (quote) {\n        s = s.replace(/\\\"/g, '&quot;');\n      }\n    }\n    // TODO: this is inadequate because it will pass `&0;`. This approach\n    // will not work, each & must be considered with regard to whether it\n    // is followed by a 100% syntactically valid entity or not, and escaped\n    // if it is not. If this bothers you, don't set parser.decodeEntities\n    // to false. (The default is true.)\n    s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, '&amp;') // Match ampersands not part of existing HTML entity\n    .replace(/</g, '&lt;').replace(/\\>/g, '&gt;');\n    if (quote) {\n      s = s.replace(/\\\"/g, '&quot;');\n    }\n    return s;\n  }\n\n  function naughtyHref(name, href) {\n    // Browsers ignore character codes of 32 (space) and below in a surprising\n    // number of situations. Start reading here:\n    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab\n    href = href.replace(/[\\x00-\\x20]+/g, '');\n    // Clobber any comments in URLs, which the browser might\n    // interpret inside an XML data island, allowing\n    // a javascript: URL to be snuck through\n    href = href.replace(/<\\!\\-\\-.*?\\-\\-\\>/g, '');\n    // Case insensitive so we don't get faked out by JAVASCRIPT #1\n    var matches = href.match(/^([a-zA-Z]+)\\:/);\n    if (!matches) {\n      // Protocol-relative URL starting with any combination of '/' and '\\'\n      if (href.match(/^[\\/\\\\]{2}/)) {\n        return !options.allowProtocolRelative;\n      }\n\n      // No scheme\n      return false;\n    }\n    var scheme = matches[1].toLowerCase();\n\n    if (has(options.allowedSchemesByTag, name)) {\n      return options.allowedSchemesByTag[name].indexOf(scheme) === -1;\n    }\n\n    return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;\n  }\n\n  /**\n   * Filters user input css properties by whitelisted regex attributes.\n   *\n   * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.\n   * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }.\n   * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).\n   * @return {object}                    - Abstract Syntax Tree with filtered style attributes.\n   */\n  function filterCss(abstractSyntaxTree, allowedStyles) {\n    if (!allowedStyles) {\n      return abstractSyntaxTree;\n    }\n\n    var filteredAST = cloneDeep(abstractSyntaxTree);\n    var astRules = abstractSyntaxTree.nodes[0];\n    var selectedRule;\n\n    // Merge global and tag-specific styles into new AST.\n    if (allowedStyles[astRules.selector] && allowedStyles['*']) {\n      selectedRule = mergeWith(cloneDeep(allowedStyles[astRules.selector]), allowedStyles['*'], function (objValue, srcValue) {\n        if (Array.isArray(objValue)) {\n          return objValue.concat(srcValue);\n        }\n      });\n    } else {\n      selectedRule = allowedStyles[astRules.selector] || allowedStyles['*'];\n    }\n\n    if (selectedRule) {\n      filteredAST.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);\n    }\n\n    return filteredAST;\n  }\n\n  /**\n   * Extracts the style attribues from an AbstractSyntaxTree and formats those\n   * values in the inline style attribute format.\n   *\n   * @param  {AbstractSyntaxTree} filteredAST\n   * @return {string}             - Example: \"color:yellow;text-align:center;font-family:helvetica;\"\n   */\n  function stringifyStyleAttributes(filteredAST) {\n    return filteredAST.nodes[0].nodes.reduce(function (extractedAttributes, attributeObject) {\n      extractedAttributes.push(attributeObject.prop + ':' + attributeObject.value + ';');\n      return extractedAttributes;\n    }, []).join('');\n  }\n\n  /**\n    * Filters the existing attributes for the given property. Discards any attributes\n    * which don't match the whitelist.\n    *\n    * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }\n    * @param  {array} allowedDeclarationsList   - List of declarations which pass whitelisting.\n    * @param  {object} attributeObject          - Object representing the current css property.\n    * @property {string} attributeObject.type   - Typically 'declaration'.\n    * @property {string} attributeObject.prop   - The CSS property, i.e 'color'.\n    * @property {string} attributeObject.value  - The corresponding value to the css property, i.e 'red'.\n    * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects\n    */\n  function filterDeclarations(selectedRule) {\n    return function (allowedDeclarationsList, attributeObject) {\n      // If this property is whitelisted...\n      if (selectedRule.hasOwnProperty(attributeObject.prop)) {\n        var matchesRegex = selectedRule[attributeObject.prop].some(function (regularExpression) {\n          return regularExpression.test(attributeObject.value);\n        });\n\n        if (matchesRegex) {\n          allowedDeclarationsList.push(attributeObject);\n        }\n      }\n      return allowedDeclarationsList;\n    };\n  }\n\n  function filterClasses(classes, allowed) {\n    if (!allowed) {\n      // The class attribute is allowed without filtering on this tag\n      return classes;\n    }\n    classes = classes.split(/\\s+/);\n    return classes.filter(function (clss) {\n      return allowed.indexOf(clss) !== -1;\n    }).join(' ');\n  }\n}\n\n// Defaults are accessible to you so that you can use them as a starting point\n// programmatically if you wish\n\nvar htmlParserDefaults = {\n  decodeEntities: true\n};\nsanitizeHtml.defaults = {\n  allowedTags: ['h3', 'h4', 'h5', 'h6', 'blockquote', 'p', 'a', 'ul', 'ol', 'nl', 'li', 'b', 'i', 'strong', 'em', 'strike', 'code', 'hr', 'br', 'div', 'table', 'thead', 'caption', 'tbody', 'tr', 'th', 'td', 'pre', 'iframe'],\n  allowedAttributes: {\n    a: ['href', 'name', 'target'],\n    // We don't currently allow img itself by default, but this\n    // would make sense if we did. You could add srcset here,\n    // and if you do the URL is checked for safety\n    img: ['src']\n  },\n  // Lots of these won't come up by default because we don't allow them\n  selfClosing: ['img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta'],\n  // URL schemes we permit\n  allowedSchemes: ['http', 'https', 'ftp', 'mailto'],\n  allowedSchemesByTag: {},\n  allowedSchemesAppliedToAttributes: ['href', 'src', 'cite'],\n  allowProtocolRelative: true\n};\n\nsanitizeHtml.simpleTransform = function (newTagName, newAttribs, merge) {\n  merge = merge === undefined ? true : merge;\n  newAttribs = newAttribs || {};\n\n  return function (tagName, attribs) {\n    var attrib;\n    if (merge) {\n      for (attrib in newAttribs) {\n        attribs[attrib] = newAttribs[attrib];\n      }\n    } else {\n      attribs = newAttribs;\n    }\n\n    return {\n      tagName: newTagName,\n      attribs: attribs\n    };\n  };\n};"],"sourceRoot":""}