{"version":3,"sources":["webpack://jfrog-ui-essentials/./node_modules/domutils/lib/legacy.js","webpack://jfrog-ui-essentials/./node_modules/domutils/lib/helpers.js"],"names":["ElementType","__webpack_require__","isTag","exports","testElement","options","element","key","hasOwnProperty","tag_name","name","tag_type","type","tag_contains","data","attribs","Checks","elem","getAttribCheck","attrib","value","combineFuncs","a","b","getElements","recurse","limit","funcs","Object","keys","map","length","this","filter","reduce","getElementById","id","Array","isArray","findOne","getElementsByTagName","getElementsByTagType","removeSubsets","nodes","node","ancestor","replace","idx","indexOf","splice","parent","POSITION","DISCONNECTED","PRECEDING","FOLLOWING","CONTAINS","CONTAINED_BY","comparePos","compareDocumentPosition","nodeA","nodeB","current","sharedParent","siblings","aSibling","bSibling","aParents","bParents","unshift","children","uniqueSort","position","slice","sort","relative"],"mappings":"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","file":"jfrog-ui-essentials.umd.min.vendors-chunks~c0d2b140.js","sourcesContent":["var ElementType = require(\"domelementtype\");\nvar isTag = exports.isTag = ElementType.isTag;\n\nexports.testElement = function(options, element){\n\tfor(var key in options){\n\t\tif(!options.hasOwnProperty(key));\n\t\telse if(key === \"tag_name\"){\n\t\t\tif(!isTag(element) || !options.tag_name(element.name)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if(key === \"tag_type\"){\n\t\t\tif(!options.tag_type(element.type)) return false;\n\t\t} else if(key === \"tag_contains\"){\n\t\t\tif(isTag(element) || !options.tag_contains(element.data)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if(!element.attribs || !options[key](element.attribs[key])){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\n\nvar Checks = {\n\ttag_name: function(name){\n\t\tif(typeof name === \"function\"){\n\t\t\treturn function(elem){ return isTag(elem) && name(elem.name); };\n\t\t} else if(name === \"*\"){\n\t\t\treturn isTag;\n\t\t} else {\n\t\t\treturn function(elem){ return isTag(elem) && elem.name === name; };\n\t\t}\n\t},\n\ttag_type: function(type){\n\t\tif(typeof type === \"function\"){\n\t\t\treturn function(elem){ return type(elem.type); };\n\t\t} else {\n\t\t\treturn function(elem){ return elem.type === type; };\n\t\t}\n\t},\n\ttag_contains: function(data){\n\t\tif(typeof data === \"function\"){\n\t\t\treturn function(elem){ return !isTag(elem) && data(elem.data); };\n\t\t} else {\n\t\t\treturn function(elem){ return !isTag(elem) && elem.data === data; };\n\t\t}\n\t}\n};\n\nfunction getAttribCheck(attrib, value){\n\tif(typeof value === \"function\"){\n\t\treturn function(elem){ return elem.attribs && value(elem.attribs[attrib]); };\n\t} else {\n\t\treturn function(elem){ return elem.attribs && elem.attribs[attrib] === value; };\n\t}\n}\n\nfunction combineFuncs(a, b){\n\treturn function(elem){\n\t\treturn a(elem) || b(elem);\n\t};\n}\n\nexports.getElements = function(options, element, recurse, limit){\n\tvar funcs = Object.keys(options).map(function(key){\n\t\tvar value = options[key];\n\t\treturn key in Checks ? Checks[key](value) : getAttribCheck(key, value);\n\t});\n\n\treturn funcs.length === 0 ? [] : this.filter(\n\t\tfuncs.reduce(combineFuncs),\n\t\telement, recurse, limit\n\t);\n};\n\nexports.getElementById = function(id, element, recurse){\n\tif(!Array.isArray(element)) element = [element];\n\treturn this.findOne(getAttribCheck(\"id\", id), element, recurse !== false);\n};\n\nexports.getElementsByTagName = function(name, element, recurse, limit){\n\treturn this.filter(Checks.tag_name(name), element, recurse, limit);\n};\n\nexports.getElementsByTagType = function(type, element, recurse, limit){\n\treturn this.filter(Checks.tag_type(type), element, recurse, limit);\n};\n","// removeSubsets\n// Given an array of nodes, remove any member that is contained by another.\nexports.removeSubsets = function(nodes) {\n\tvar idx = nodes.length, node, ancestor, replace;\n\n\t// Check if each node (or one of its ancestors) is already contained in the\n\t// array.\n\twhile (--idx > -1) {\n\t\tnode = ancestor = nodes[idx];\n\n\t\t// Temporarily remove the node under consideration\n\t\tnodes[idx] = null;\n\t\treplace = true;\n\n\t\twhile (ancestor) {\n\t\t\tif (nodes.indexOf(ancestor) > -1) {\n\t\t\t\treplace = false;\n\t\t\t\tnodes.splice(idx, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tancestor = ancestor.parent;\n\t\t}\n\n\t\t// If the node has been found to be unique, re-insert it.\n\t\tif (replace) {\n\t\t\tnodes[idx] = node;\n\t\t}\n\t}\n\n\treturn nodes;\n};\n\n// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition\nvar POSITION = {\n\tDISCONNECTED: 1,\n\tPRECEDING: 2,\n\tFOLLOWING: 4,\n\tCONTAINS: 8,\n\tCONTAINED_BY: 16\n};\n\n// Compare the position of one node against another node in any other document.\n// The return value is a bitmask with the following values:\n//\n// document order:\n// > There is an ordering, document order, defined on all the nodes in the\n// > document corresponding to the order in which the first character of the\n// > XML representation of each node occurs in the XML representation of the\n// > document after expansion of general entities. Thus, the document element\n// > node will be the first node. Element nodes occur before their children.\n// > Thus, document order orders element nodes in order of the occurrence of\n// > their start-tag in the XML (after expansion of entities). The attribute\n// > nodes of an element occur after the element and before its children. The\n// > relative order of attribute nodes is implementation-dependent./\n// Source:\n// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n//\n// @argument {Node} nodaA The first node to use in the comparison\n// @argument {Node} nodeB The second node to use in the comparison\n//\n// @return {Number} A bitmask describing the input nodes' relative position.\n//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n//         a description of these values.\nvar comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {\n\tvar aParents = [];\n\tvar bParents = [];\n\tvar current, sharedParent, siblings, aSibling, bSibling, idx;\n\n\tif (nodeA === nodeB) {\n\t\treturn 0;\n\t}\n\n\tcurrent = nodeA;\n\twhile (current) {\n\t\taParents.unshift(current);\n\t\tcurrent = current.parent;\n\t}\n\tcurrent = nodeB;\n\twhile (current) {\n\t\tbParents.unshift(current);\n\t\tcurrent = current.parent;\n\t}\n\n\tidx = 0;\n\twhile (aParents[idx] === bParents[idx]) {\n\t\tidx++;\n\t}\n\n\tif (idx === 0) {\n\t\treturn POSITION.DISCONNECTED;\n\t}\n\n\tsharedParent = aParents[idx - 1];\n\tsiblings = sharedParent.children;\n\taSibling = aParents[idx];\n\tbSibling = bParents[idx];\n\n\tif (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n\t\tif (sharedParent === nodeB) {\n\t\t\treturn POSITION.FOLLOWING | POSITION.CONTAINED_BY;\n\t\t}\n\t\treturn POSITION.FOLLOWING;\n\t} else {\n\t\tif (sharedParent === nodeA) {\n\t\t\treturn POSITION.PRECEDING | POSITION.CONTAINS;\n\t\t}\n\t\treturn POSITION.PRECEDING;\n\t}\n};\n\n// Sort an array of nodes based on their relative position in the document and\n// remove any duplicate nodes. If the array contains nodes that do not belong\n// to the same document, sort order is unspecified.\n//\n// @argument {Array} nodes Array of DOM nodes\n//\n// @returns {Array} collection of unique nodes, sorted in document order\nexports.uniqueSort = function(nodes) {\n\tvar idx = nodes.length, node, position;\n\n\tnodes = nodes.slice();\n\n\twhile (--idx > -1) {\n\t\tnode = nodes[idx];\n\t\tposition = nodes.indexOf(node);\n\t\tif (position > -1 && position < idx) {\n\t\t\tnodes.splice(idx, 1);\n\t\t}\n\t}\n\tnodes.sort(function(a, b) {\n\t\tvar relative = comparePos(a, b);\n\t\tif (relative & POSITION.PRECEDING) {\n\t\t\treturn -1;\n\t\t} else if (relative & POSITION.FOLLOWING) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t});\n\n\treturn nodes;\n};\n"],"sourceRoot":""}